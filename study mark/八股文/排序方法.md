C++中常用的八大排序算法包括以下几种：

# 冒泡排序 (Bubble Sort):

原理：通过重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。
特点：简单直观，但效率较低，时间复杂度为O(n²)。

# 选择排序 (Selection Sort):

原理：每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。
特点：简单直观，时间复杂度为O(n²)，但不是稳定排序。
# 插入排序 (Insertion Sort):

原理：在一个已经有序的小序列的基础上，一次插入一个元素，得到一个新的有序序列。
特点：适合小规模数据和部分有序的数据，时间复杂度为O(n²)，是稳定排序。
# 快速排序 (Quick Sort):

原理：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序。
特点：平均时间复杂度为O(n log n)，但最坏情况下是O(n²)，时间复杂度不稳定，但通常性能较好，且是不稳定排序。
# 归并排序 (Merge Sort):

原理：采用分治法，将一个序列分成两个子序列，分别排序后再合并。
特点：稳定排序，时间复杂度为O(n log n)，适合大规模数据排序，但需要额外的存储空间。
# 堆排序 (Heap Sort):

原理：利用堆这种数据结构来对数据进行排序。
特点：不稳定排序，时间复杂度为O(n log n)，空间复杂度为O(1)。
# 希尔排序 (Shell Sort):

原理：希尔排序也是一种插入排序，是简单插入排序经过改进后的一个更高效的版本。希尔排序通过比较相距一定间隔的元素来工作。
特点：时间复杂度介于O(n)和O(n²)之间，具体取决于间隔序列的选择，空间复杂度为O(1)。
# 计数排序 (Counting Sort):

原理：计数排序假设输入的数据范围在0到k之间，且k不是特别大的整数。然后创建一个大小为k+1的数组，用于存储每个数字出现的次数。
特点：计数排序适用于整数排序，且数据范围不是很大的情况，时间复杂度为O(n+k)，空间复杂度为O(k)，是稳定排序。